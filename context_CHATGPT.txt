Ниже привожу подробное резюме всей информации, которая поможет тебе быстро вникнуть в суть и архитектуру торгового бота, а также разобраться с его основными компонентами и особенностями.

Общий обзор проекта
Цель проекта:
Создать автоматизированного торгового бота для скальпинга, который использует модель-трансформер для прогнозирования краткосрочных изменений цены на основе данных о ликвидности (LOB). Бот предназначен для работы с Bybit API v5 и собирает данные из архивов с информацией об ордербуках (как snapshot, так и delta-сообщения). Вся архитектура разделена на несколько модулей для облегчения поддержки и масштабирования:

Сбор данных (dataset_builder.py):

Скачивает архивы LOB-данных для заданных торговых пар и дат (диапазоны указаны в config.py).
Обрабатывает как snapshot, так и delta-сообщения для формирования корректного текущего состояния ордербука.
Обработка происходит в многопоточном режиме, с возможностью выбора конкретной торговой пары (опциональный параметр --pair-index).
Каждый обработанный день сохраняется в отдельный файл в папке data (имя файла – <pair>_<date>.pkl).
Обучение модели (train_transformer.py):

Обучение происходит на датасете, собранном (или объединённом) из файлов в папке data.
Входной вектор для модели состоит из двух частей: flattened LOB-данных (последовательность из снимков) и признаков свечей (5-минутные свечи за последние 5 часов, итого 120 признаков).
Модель-трансформер (CombinedModel) оптимизируется с использованием Optuna, а окончательная версия сохраняется (например, в final_model.pth).
Live-трейдинг (live_trading.py):

Использует обученную модель для торговли в реальном времени.
Получает LOB-данные через WebSocket (bybit_ws.py) и данные свечей через REST API (bybit_api.py).
Формирует входной вектор точно в том же формате, что и для обучения, чтобы модель делала прогнозы, на основе которых бот открывает/закрывает сделки.
В коде реализована логика управления рисками, cooldown-периоды при ошибках или низкой эффективности, а также обработка волатильности.
Основные компоненты проекта
config.py:
Здесь собраны все ключевые настройки:

Диапазоны дат для загрузки данных (с 2024 года).
Шаблон URL архивов, список торговых пар (SYMBOLS), параметры ордеров, риск-менеджмента и настройки модели.
Параметры подключения к API (REST и WebSocket) и настройки режимов (например, paper trading).
model.py:
Определяет архитектуру модели – трансформер, который принимает на вход объединённый вектор (LOB + свечные признаки) и выдаёт прогноз изменения цены.

dataset.py:
Содержит:

Класс LOBDataset, который проходит по архивам, обрабатывая каждую запись с учетом snapshot и delta-сообщений.
Функцию process_archive(url), которая используется для параллельной обработки одного архива и формирования выборок (samples).
dataset_builder.py:

Принимает опциональный параметр командной строки --pair-index для выбора конкретной торговой пары (или обрабатывает все, если параметр не задан).
Формирует список URL архивов для выбранных пар и дат.
Использует многопоточность (ThreadPoolExecutor) для параллельной обработки архивов.
После обработки каждого архива данные за один день сохраняются в отдельный файл в папке data.
train_transformer.py:

Загружает собранный датасет (либо объединяет файлы из папки data) и обучает модель с использованием Optuna для оптимизации гиперпараметров.
live_trading.py:

Запускает торгового бота, который подключается к Bybit через WebSocket и REST API, получает актуальные данные, формирует входной вектор и принимает торговые решения на основе прогноза модели.
bybit_api.py и bybit_ws.py:

Реализуют работу с официальным API Bybit v5 (подпись запросов, получение баланса, ордеров, свечей и работа с WebSocket).
requirements.txt:
Содержит список зависимостей (aiohttp, websockets, optuna, torch, tqdm, numpy, requests).

Ключевые моменты и рекомендации
Обработка данных:
Датасет формируется из архивов, где корректно обрабатываются как snapshot, так и delta-сообщения. Это гарантирует, что текущее состояние ордербука обновляется в режиме реального времени, и данные для обучения максимально соответствуют реальным условиям торговли.

Формат входных данных:
Входной вектор состоит из flatten LOB-снимков и 120 признаков свечей. Важно, чтобы этот формат был одинаковым для обучения и live-трейдинга.

Многопоточность и распределение нагрузки:
dataset_builder.py позволяет запускать обработку для конкретной пары (через параметр --pair-index), что удобно для распределения нагрузки между серверами.

Управление рисками:
В live_trading.py реализованы различные механизмы (cooldown, проверка волатильности, контроль уверенности модели) для защиты капитала.

Тестирование:
Перед использованием на реальных счетах обязательно проведи тестирование в режиме paper trading, чтобы убедиться в корректности обработки данных, стабильности работы API и правильности торговых алгоритмов.

Надеюсь, это резюме поможет тебе быстро разобраться в проекте и продолжить его развитие без лишних проблем. Если будут вопросы или понадобится помощь — смело обращайся к документации и комментариям в коде, они содержат важные пояснения по каждой части системы.